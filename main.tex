
\documentclass[11pt]{article}

\input{macro}

\usepackage{titling}

\usepackage{times}

\usepackage{titlesec}% http://ctan.org/pkg/titlesec
\titleformat{\section}%
  [hang]% <shape>
  {\normalfont\bfseries\Large}% <format>
  {}% <label>
  {0pt}% <sep>
  {}% <before code>
\renewcommand{\thesection}{}% Remove section references...
\renewcommand{\thesubsection}{\arabic{subsection}}%... from subsections

\setlength{\droptitle}{-5.5em} 

\setlength{\topmargin}{-.6in} 
\setlength{\textheight}{9in}
\setlength{\textwidth}{7in} 
\setlength{\headheight}{26pt}
\setlength{\headsep}{9pt} 
\setlength{\oddsidemargin}{-.26in}
\setlength{\evensidemargin}{.25in}

\begin{document}

\title{Research Summary}
\author{Tanakorn Leesatapornwongsa}
\date{\vspace{-1ex} \small{Department of Computer Science, University of
Chicago}}

\maketitle

My research focuses on improving the dependability of distributed and cloud
systems in the aspect of reliability. The unsolved reliability problem in cloud
systems that I am tackling is \textit{distributed concurrency bugs (DC bugs)}.
Similar to local concurrency bugs (LC bugs), which are bugs caused by
non-deterministic computing order of threads, DC bugs are caused by
non-deterministic order of distributed events. Non-deterministic distributed
events could be message processing (network could re-order messages), or
machine crashes (hardware fault can happen randomly), \etc\ Possible
interleavings of distributed events are beyond developers' imagination and
some are not handled properly which could cause catastrophic failures such as
data loss, data inconsistencies, and downtimes. In order to combat DC bugs,
I will pursue three objectives in advancing system dependability including
\textit{DC-bug study}, \textit{offline testing}, and \textit{runtime supports}.
The following sections describe in detail my research work grouped by status.

\section*{Current Work}

\subsection{DC-Bug Study}

To combat DC bugs, I started my research by formally studying them to
comprehend their characteristics and identify opportunities to build new DC-bug
detection tools. Our group and I have created the largest and most
comprehensive taxonomy of 104 real-world DC bugs named TaxDC from Cassandra,
HBase, Hadoop MapReduce/Yarn, and ZooKeeper. TaxDC contains in-depth
characteristics of DC bugs, stored in the form of 2083 classification labels
and 4528 lines of re-enumerated steps to the bugs that we manually added. 

With TaxDC, I can answer important questions such as: What types of DC bugs
exist in real world? What are the root causes of DC bugs (out-of-order
messages, hardware failures, \etc)? Can existing LC-bug-detection tools
applicable for DC bugs? How do developers fix DC bugs (by adding locks, states,
\etc)? How do propagation chains form from the root causes to errors? The
answers for these questions guide the subsequent my research projects.

\subsection{Offline Testing}

After I have comprehended the characteristics of DC bugs, I started tackle DC
bugs by offline testing approach. One powerful method for discovering hidden DC
bugs is the use of an implementation-level distributed system model checker
(dmck). Dmcks discover buggy interleavings by try re-ordering all
non-deterministic distributed events. However, one big problem of dmck is the
state-space explosion (\ie, there are too many events to re-order). In order to
mitigate this, existing dmcks adopt basic reduction techniques. Despite these
early successes, existing approaches are still impractical to unearth real-world
bugs due to complex non-determinism that could happen (\eg, an additional crash
during current crash recovery), so my research is advancing the state of the art
of dmck to make it possible to test real-world cloud systems.

\subsubsection*{Initial work: Semantic-Aware Model Checking} 

To start with, I specifically addressed a limitation of existing dmcks which is
they treat every target system as a black box, and therefore perform unnecessary
reorderings of distributed events that would lead to the same explored states
(\ie, redundant executions). Thus, I built Semantic-Aware Model Checker (SAMC)
(\textit{OSDI '14, ISSTA '15}), a white-box model checker that takes semantic
knowledge of how distributed events are processed by the target system and
incorporates that information to create reduction policies. The policies are
based on sound reduction techniques and they tell a dmck not to re-order some
pairs of events, because those re-orderings are redundant.

\subsubsection*{Ongoing work: Automatically Generated Reduction Strategies} 

As we leverage domain-specific knowledge into reduction strategies, this process
is done by hand that means it requires developers manually extract and
incorporate the knowledge to write the corresponding reduction policies. This
manual process is based on high-level human understanding of the codebase, which
prone to human errors, and could breaks soundness.

I address the unsoundness of SAMC and the developers' burden in writing
semantic-based reduction policies by evolving SAMC into AutoSAMC, a dmck that
automatically and soundly extracts complete semantic knowledge into reduction
strategies. I combine symbolic execution with dmck. While others have used
symbolic execution with model checking for LC bugs, AutoSAMC will be the first
case for implementation-level dmck. 

\section*{Future Work}

\subsection{Runtime Support}

While my current work is on an offline approach, my future plan includes runtime
supports to combat DC bugs. I plan to build three runtime supports as shown
below.

\if 0
\subsubsection*{Runtime DC-Bug Statistical Debugging}

Statistical debugging has been used effectively for detecting performance
anomalies in distributed systems and for comparing success- and failure-run
traces to help identify LC-bug triggering conditions. Such an approach can also
be powerful to unearth DC bugs uncaught in offline approaches and useful to
developers who want to debug customer deployments. Thus, I will start by
building a runtime monitoring and statistical debugging support to catch DC bugs
in live deployments, specifically by pinpointing the triggering conditions.

\subsubsection*{Runtime DC-Bug Prevention}

Since generating patches to deployments can take time, we need to prevent
DC-bug-induced failues when developers are working on the patches. Our study
shows that many DC bugs can be prevented by altering the timings of a few set of
events, or by retrying or discarding some messages. This creates significant
opportunities for online DC bug prevention. My plan is to develop a runtime
prevention layer built around each node of the target system that manipulates
event timing and processing to prevent failures so developers can program the
runtime prevention layer on the fly to apply simple fixes.

\subsubsection*{Runtime DC-Bug Recovery}

Since runtime prevention depends on input specification, it cannot guarantee
100\% bug coverage.  If failures happen at critical nodes (\eg, master node),
users can face downtimes. Thus, we need to transparently recover from DC bugs in
production runs, minimizing user-visible failures. Thus, I will build a runtime
recovery mechanism that performs checkpoint and rollback to mask failures out
from users' visibility.
\fi

\end{document}

