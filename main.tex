
\documentclass[11pt]{article}

\input{macro}

\usepackage{titling}

\usepackage{times}

\setlength{\droptitle}{-5.5em} 

\setlength{\topmargin}{-.6in} 
\setlength{\textheight}{9.2in}
\setlength{\textwidth}{7in} 
\setlength{\headheight}{26pt}
\setlength{\headsep}{9pt} 
\setlength{\oddsidemargin}{-.26in}
\setlength{\evensidemargin}{.25in}

\begin{document}

\title{Research Summary}
\author{Tanakorn Leesatapornwongsa}
\date{\vspace{-1ex} \small{Department of Computer Science, University of
Chicago}}

\maketitle

\vspace{-1ex} 
My research focuses on improving the dependability of cloud-scale distributed
systems such as scale-out storage systems, distributed computing frameworks,
and cluster management services. Unfulfilled dependability is costly. Internet
service companies collectively lose billions of dollars in revenue each year
from service downtimes. Yet, there are complex challenges to reach an ideal
dependability. 

I find that one unsolved dependability problem in cloud systems is
\textbf{\textit{distributed concurrency bugs (DC bugs)}}. DC bugs are caused by
non-deterministic order of distributed events such as message arrivals, faults,
and reboots. Cloud systems execute multiple complicated distributed protocols
concurrently (\eg, serving users' requests, operating some background tasks,
and combined with untimely hardware failures). The possible interleavings of
the distributed events are beyond developers' imagination and some
interleavings might not be handled properly. The buggy interleavings can cause
catastrophic failures such as data loss, data inconsistencies, and downtimes. 

To combat DC bugs, I establish my research in (1) \textbf{\textit{formal bug
studies}} and (2) \textbf{\textit{distributed system model checking}}. The
following sections explain my research in detail and how applicable it is to
Facebook.

\section{Bug Study}

Bug or failure studies can significantly guide many aspects of dependability
research. Many dependability researchers recently employ formal studies on bugs
and failures such as a large-scale study of flash memory failures from Facebook
that can identify opportunities for new research. For distributed system bugs,
few studies exist but they did not dissect DC bugs, and there is no large-scale
study of DC bugs. 

To fill the void, I as one of the project leaders, have created the largest and
most comprehensive taxonomy of 104 real-world DC bugs (named \taxdc) from
Cassandra, HBase, Hadoop MapReduce/Yarn, and ZooKeeper issue repositories [in
submission to \textit{ASPLOS
'16} \footnote{http://ucare.cs.uchicago.edu/pdf/insubm-TaxDC.pdf}]. \taxdc\
contains in-depth characteristics of DC bugs that help us answer important
questions such as: What types of DC bugs exist in real world? What are the root
causes of DC bugs?  How do developers fix DC bugs? How do propagation chains
form from the root causes to errors? The answers to these questions will help
guide research in combating DC bugs.

\section{Distributed System Model Checking}

One powerful method for discovering hidden DC bugs is the use of an
\textit{implementation-level distributed system model checker} (\textbf{dmck}).
Dmck discovers hidden DC bugs by re-ordering all non-deterministic distributed
events. However, one big challenge faced by dmck is the state-space explosion
problem (\ie, there are too many distributed events to re-order). In order to
address this, existing dmcks adopt basic reduction techniques such as dynamic
partial order reduction (DPOR). Despite these early successes, existing
approaches are still impractical to unearth real-world bugs, so I am advancing
the state of the art of dmck to combat DC bugs, which I describe below.

\subsection{Semantic-Aware Model Checking (Initial Work)} 

I started my work by specifically addressing two limitations of existing dmcks.
First, existing dmcks treat target system as a complete black box, and perform
unnecessary reorderings of distributed events that would lead to the same
explored states (\ie, redundant executions). Second, they do not incorporate
complex multiple fault events (\eg, crashes, reboots) into their checks, as such
inclusion would exacerbate the state-space explosion problem.

To address these limitations, I introduced Semantic-Aware Model Checking
(\textbf{SAMC}) [appeared in \textit{OSDI
'14} \footnote{http://ucare.cs.uchicago.edu/pdf/osdi14-samc.pdf}, \textit{ISSTA
'15} \footnote{http://ucare.cs.uchicago.edu/pdf/issta15-samc.pdf}], a novel
white-box model checking approach that takes \textit{semantic knowledge} of how
distributed events (specifically, messages, crashes, and reboots) are processed
and incorporates that information to create reduction policies. The policies are
based on sound reduction techniques such as DPOR and symmetry. The policies tell
dmck not to re-order some pairs of events such as message-message pairs or
crash-message pairs, yet preserves soundness, because those cut out re-orderings
are redundant.

I built SAMC from scratch with 10 KLOC and I was able to reproduce 12 old bugs
in Cassandra, Hadoop MapReduce, and ZooKeeper up to 271x (33x on average) faster
compared to state-of-the-art techniques. Some bugs cannot be detected by
non-SAMC approaches, even after two days. And I found two new bugs in these
systems.

\subsection{Automated Semantic-Aware Model Checking (Ongoing Work)} 

So far, as we leverage domain-specific semantic information into reduction
strategies, we (or the developers) must manually extract and incorporate the
semantic knowledge and write the corresponding reduction policies. This manual
process is based on high-level human understanding of the codebase, which can
potentially miss important re-orderings due to human errors, and breaks
soundness.

To address the unsoundness of SAMC, and the developers' burden in manually
writing semantic-based reduction strategies, I am developing \autocheck, a dmck
that automatically and soundly extracts semantic knowledge into reduction
strategies with the help of static analysis. I am combining symbolic execution
and dmck. \autocheck\ will be the first case for implementation-level dmck that
adopts symbolic execution. 

\subsection{Deep Semantic-Aware Model Checking (Future Work)}

Execution paths to DC bugs often requires complex input preconditions such as
multiple faults, reboots, and protocol initiations. I found that more than 60\%
of DC bugs require more than one protocol initiations, 35\% require multiple
faults, and 29\% of DC bugs arise within buggy interactions between foreground
and background protocols.  This again highlights the complexity of fully
complete systems. If we do not include the complex preconditions, the bugs will
not surface.

To address this complexity, I will construct \deepcheck, a dmck with a backward
static analysis tool that is capable of searching the necessary input
preconditions to cover unreachable paths. The concept of \deepcheck\ is the dmck
will run with a limited input precondition. Then, \deepcheck\ will analyze which
code path is not reachable given the limited input. It will perform a backward
analysis to search for input preconditions to the path. As a result, this
backward analysis will provide the sequence of input preconditions that cover
more complex scenarios.

\section{Research Applicability}

One factor behind the success of Facebook is its robust large-scale data
centers. Facebook has developed a number of cloud-scale systems such as
Cassandra, f4, Haystack, Scuba, TAO,and Unicorn. Facebook's systems were
written in gigantic size of codebase and if not thoroughly tested, there could
be corner-case bugs hidden.

Facebook has developed tools to detect bugs such as Facebook Infer, static
analyzer for mobile apps. For cloud systems, a Facebook engineer collaborated
with my advisor to build \fad\ [\textit{NSDI '11}], a testing framework for
distributed systems that injects multiple faults to catch DC bugs due to fault
timing. However, \fad\ do not address untimely message arrivals, they can
discover just a subset of DC bugs.

As shown in SAMC, I successfully model checked Cassandra and the others. My
model checking framework is also applicable to other systems as well. To
integrate SAMC with existing systems, it does not need to modify the current
codebase, so it does not interrupt ongoing development processes. As I envision,
my future work is on automated systems verification (\ie, \autocheck\ and
\deepcheck). If Facebook adopts them, they will help improve dependability of
Facebook's systems and reduce the cost of verification process at Facebook.

\end{document}

